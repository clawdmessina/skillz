<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>skillz — agent skill loadout picker</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
<style>
/* ============================================================
   SKILLZ — Design System
   Aesthetic: Industrial terminal meets luxury dashboard.
   Dark, sharp, deliberate. Neon accents on carbon surfaces.
   ============================================================ */

*, *::before, *::after {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

:root {
  --bg-deep: #08090c;
  --bg-surface: #0f1115;
  --bg-elevated: #161920;
  --bg-hover: #1c2029;
  --border-subtle: #1e222a;
  --border-medium: #2a2f3a;
  --border-bright: #3a4050;

  --text-primary: #e8eaf0;
  --text-secondary: #8b90a0;
  --text-muted: #555a6a;
  --text-dim: #3a3f50;

  --accent-cyan: #22d3ee;
  --accent-cyan-dim: rgba(34, 211, 238, 0.15);
  --accent-cyan-glow: rgba(34, 211, 238, 0.3);
  --accent-orange: #fb923c;
  --accent-orange-dim: rgba(251, 146, 60, 0.15);
  --accent-green: #4ade80;
  --accent-green-dim: rgba(74, 222, 128, 0.15);
  --accent-rose: #fb7185;
  --accent-rose-dim: rgba(251, 113, 133, 0.15);
  --accent-violet: #a78bfa;
  --accent-violet-dim: rgba(167, 139, 250, 0.15);

  --radius-sm: 4px;
  --radius-md: 8px;
  --radius-lg: 12px;

  --font-display: 'Outfit', sans-serif;
  --font-body: 'Outfit', sans-serif;
  --font-mono: 'JetBrains Mono', monospace;

  --transition-fast: 120ms ease;
  --transition-med: 250ms cubic-bezier(0.4, 0, 0.2, 1);
}

html {
  font-size: 15px;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

body {
  background: var(--bg-deep);
  color: var(--text-primary);
  font-family: var(--font-body);
  min-height: 100vh;
  overflow-x: hidden;
}

/* Noise texture overlay */
body::before {
  content: '';
  position: fixed;
  inset: 0;
  background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.03'/%3E%3C/svg%3E");
  pointer-events: none;
  z-index: 9999;
}

/* ---- LAYOUT ---- */

.app {
  display: grid;
  grid-template-rows: auto 1fr auto;
  min-height: 100vh;
}

/* ---- HEADER ---- */

header {
  padding: 20px 32px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-bottom: 1px solid var(--border-subtle);
  background: var(--bg-surface);
  position: relative;
}

header::after {
  content: '';
  position: absolute;
  bottom: -1px;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, transparent, var(--accent-cyan) 30%, var(--accent-violet) 70%, transparent);
  opacity: 0.4;
}

.logo {
  display: flex;
  align-items: baseline;
  gap: 12px;
}

.logo h1 {
  font-family: var(--font-mono);
  font-size: 1.4rem;
  font-weight: 700;
  letter-spacing: -0.5px;
  color: var(--text-primary);
}

.logo h1 span {
  color: var(--accent-cyan);
}

.logo .tagline {
  font-family: var(--font-mono);
  font-size: 0.7rem;
  color: var(--text-muted);
  letter-spacing: 2px;
  text-transform: uppercase;
}

.header-actions {
  display: flex;
  gap: 8px;
}

/* ---- BUTTONS ---- */

.btn {
  font-family: var(--font-mono);
  font-size: 0.75rem;
  font-weight: 500;
  letter-spacing: 0.5px;
  text-transform: uppercase;
  padding: 8px 16px;
  border: 1px solid var(--border-medium);
  border-radius: var(--radius-sm);
  background: var(--bg-elevated);
  color: var(--text-secondary);
  cursor: pointer;
  transition: all var(--transition-fast);
  position: relative;
  overflow: hidden;
}

.btn:hover {
  border-color: var(--border-bright);
  color: var(--text-primary);
  background: var(--bg-hover);
}

.btn-primary {
  background: var(--accent-cyan);
  color: var(--bg-deep);
  border-color: var(--accent-cyan);
  font-weight: 700;
}

.btn-primary:hover {
  background: #06b6d4;
  border-color: #06b6d4;
  color: var(--bg-deep);
  box-shadow: 0 0 20px var(--accent-cyan-glow);
}

.btn-primary:active {
  transform: scale(0.97);
}

.btn-primary.copied,
.btn-export.copied {
  background: var(--accent-green);
  border-color: var(--accent-green);
  color: var(--bg-deep);
}

.btn-export {
  border-color: var(--accent-violet);
  color: var(--accent-violet);
}

.btn-export:hover:not(:disabled) {
  background: var(--accent-violet-dim);
  border-color: var(--accent-violet);
  color: var(--accent-violet);
}

.btn:disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

/* ---- MAIN CANVAS AREA ---- */

main {
  display: flex;
  flex-direction: column;
  padding: 0;
  overflow: hidden;
  position: relative;
}

/* Radial glow behind the graph */
main::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 600px;
  height: 600px;
  background: radial-gradient(circle at center, rgba(34, 211, 238, 0.04) 0%, rgba(167, 139, 250, 0.02) 40%, transparent 70%);
  pointer-events: none;
}

/* ---- GRAPH VISUALIZATION ---- */

.graph-container {
  position: relative;
  width: 100%;
  height: 100%;
  flex: 1;
}

.graph-svg {
  width: 100%;
  height: 100%;
  display: block;
}

/* ---- EDGES ---- */

.graph-edge {
  fill: none;
  stroke: var(--border-medium);
  stroke-width: 1.5;
  transition: all var(--transition-med);
}

.graph-edge.highlighted {
  stroke: var(--accent-cyan);
  stroke-width: 1.5;
  opacity: 0.6;
}

/* ---- RING GUIDES ---- */

.ring-guide {
  fill: none;
  stroke: var(--border-subtle);
  stroke-width: 0.5;
  stroke-dasharray: 4 6;
  opacity: 0.4;
}

/* ---- NODES ---- */

.graph-node {
  cursor: grab;
}

.graph-node:active {
  cursor: grabbing;
}

.graph-node.root-node {
  cursor: grab;
}

.graph-node.root-node:active {
  cursor: grabbing;
}

.node-body {
  fill: var(--bg-elevated);
  stroke: var(--border-medium);
  stroke-width: 1.5;
  transition: all var(--transition-med);
}

.graph-node:hover .node-body {
  fill: var(--bg-hover);
  stroke: var(--border-bright);
}

.graph-node.selected .node-body {
  fill: var(--accent-cyan-dim);
  stroke: var(--accent-cyan);
  filter: drop-shadow(0 0 10px var(--accent-cyan-glow));
}

.graph-node.ancestor .node-body {
  stroke: var(--accent-cyan);
  stroke-opacity: 0.5;
}

.graph-node.partial .node-body {
  stroke: var(--accent-cyan);
  stroke-opacity: 0.35;
  stroke-dasharray: 4 3;
}

.node-label {
  fill: var(--text-secondary);
  font-family: var(--font-mono);
  font-size: 10.5px;
  font-weight: 500;
  text-anchor: middle;
  dominant-baseline: central;
  pointer-events: none;
  transition: fill var(--transition-med);
}

.graph-node.selected .node-label,
.graph-node:hover .node-label {
  fill: var(--text-primary);
}

.graph-node.ancestor .node-label {
  fill: var(--text-primary);
  opacity: 0.7;
}

.node-type-badge {
  font-family: var(--font-mono);
  font-size: 7.5px;
  font-weight: 600;
  letter-spacing: 0.8px;
  text-transform: uppercase;
  text-anchor: middle;
  dominant-baseline: central;
  pointer-events: none;
}

.badge-skill { fill: var(--accent-orange); }
.badge-template { fill: var(--accent-violet); }
.badge-category { fill: var(--text-dim); }
.badge-root { fill: var(--accent-cyan); }

/* Root node — dominant center hub */
.graph-node.root-node .node-body {
  fill: var(--bg-surface);
  stroke: var(--accent-cyan);
  stroke-width: 2.5;
  filter: drop-shadow(0 0 30px rgba(34, 211, 238, 0.12)) drop-shadow(0 0 60px rgba(34, 211, 238, 0.06));
}

.graph-node.root-node .node-label {
  fill: var(--accent-cyan);
  font-size: 16px;
  font-weight: 700;
  letter-spacing: 2px;
}

.graph-node.root-node:hover .node-body {
  stroke: var(--accent-cyan);
  stroke-width: 3;
  filter: drop-shadow(0 0 36px rgba(34, 211, 238, 0.2)) drop-shadow(0 0 70px rgba(34, 211, 238, 0.1));
}

.graph-node.root-node:hover .node-label {
  fill: #fff;
}

/* ---- LOADOUT TRAY ---- */

.loadout-tray {
  border-top: 1px solid var(--border-subtle);
  background: var(--bg-surface);
  padding: 16px 32px;
  position: relative;
  min-height: 60px;
  transition: all var(--transition-med);
}

.loadout-tray::before {
  content: '';
  position: absolute;
  top: -1px;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, transparent, var(--accent-cyan) 30%, var(--accent-violet) 70%, transparent);
  opacity: 0.2;
}

.loadout-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}

.loadout-title {
  font-family: var(--font-mono);
  font-size: 0.7rem;
  font-weight: 600;
  letter-spacing: 2px;
  text-transform: uppercase;
  color: var(--text-muted);
}

.token-count {
  font-family: var(--font-mono);
  font-size: 0.8rem;
  color: var(--text-secondary);
}

.token-count .num {
  color: var(--accent-cyan);
  font-weight: 600;
}

.loadout-items {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.loadout-empty {
  font-family: var(--font-mono);
  font-size: 0.75rem;
  color: var(--text-dim);
  letter-spacing: 0.5px;
}

.loadout-chip {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 5px 10px;
  border: 1px solid var(--border-medium);
  border-radius: var(--radius-sm);
  background: var(--bg-elevated);
  font-family: var(--font-mono);
  font-size: 0.7rem;
  color: var(--text-primary);
  animation: chipIn 200ms cubic-bezier(0.34, 1.56, 0.64, 1);
}

@keyframes chipIn {
  from { opacity: 0; transform: scale(0.8) translateY(4px); }
  to { opacity: 1; transform: scale(1) translateY(0); }
}

.loadout-chip .chip-path { color: var(--text-muted); }
.loadout-chip .chip-name { color: var(--text-primary); }
.loadout-chip .chip-tokens { color: var(--text-dim); font-size: 0.65rem; }

.loadout-chip.chip-skill { border-color: rgba(251, 146, 60, 0.3); }
.loadout-chip.chip-skill .chip-name { color: var(--accent-orange); }
.loadout-chip.chip-template { border-color: rgba(167, 139, 250, 0.3); }
.loadout-chip.chip-template .chip-name { color: var(--accent-violet); }

.loadout-chip .chip-remove {
  cursor: pointer;
  color: var(--text-dim);
  margin-left: 2px;
  transition: color var(--transition-fast);
}

.loadout-chip .chip-remove:hover {
  color: var(--accent-rose);
}

/* ---- TOOLTIP ---- */

.tooltip {
  position: fixed;
  z-index: 1000;
  padding: 8px 12px;
  background: var(--bg-elevated);
  border: 1px solid var(--border-medium);
  border-radius: var(--radius-sm);
  font-family: var(--font-mono);
  font-size: 0.7rem;
  color: var(--text-secondary);
  pointer-events: none;
  opacity: 0;
  transform: translateY(4px);
  transition: opacity 150ms ease, transform 150ms ease;
  max-width: 350px;
  line-height: 1.5;
  box-shadow: 0 8px 24px rgba(0,0,0,0.5);
}

.tooltip.visible {
  opacity: 1;
  transform: translateY(0);
}

.tooltip .tip-name { color: var(--text-primary); font-weight: 600; margin-bottom: 4px; }
.tooltip .tip-desc { color: var(--text-muted); font-size: 0.65rem; }

/* ---- NODE ENTER ANIMATION ---- */

@keyframes nodeAppear {
  from { opacity: 0; transform: scale(0.5); }
  to { opacity: 1; transform: scale(1); }
}

.graph-node {
  animation: nodeAppear 350ms cubic-bezier(0.34, 1.56, 0.64, 1) backwards;
}

/* ---- RESPONSIVE ---- */

@media (max-width: 768px) {
  header { padding: 16px; }
  main { padding: 12px 8px; }
  .loadout-tray { padding: 12px 16px; }
  .logo .tagline { display: none; }
}
</style>
</head>
<body>

<div class="app">
  <header>
    <div class="logo">
      <h1>skill<span>z</span></h1>
      <span class="tagline">agent skill loadout picker</span>
    </div>
    <div class="header-actions">
      <button class="btn btn-export" id="btn-export" disabled>export layout</button>
      <button class="btn" id="btn-reset-zoom">reset view</button>
      <button class="btn" id="btn-clear" disabled>clear</button>
      <button class="btn btn-primary" id="btn-copy" disabled>copy loadout</button>
    </div>
  </header>

  <main>
    <div class="graph-container" id="graph-container">
      <svg class="graph-svg" id="graph-svg"></svg>
    </div>
  </main>

  <div class="loadout-tray" id="loadout-tray">
    <div class="loadout-header">
      <span class="loadout-title">loadout</span>
      <div class="loadout-stats">
        <span class="token-count" id="token-count"></span>
      </div>
    </div>
    <div class="loadout-items" id="loadout-items">
      <span class="loadout-empty" id="loadout-empty">click a skill node to begin building your loadout</span>
    </div>
  </div>
</div>

<div class="tooltip" id="tooltip"></div>

<script>
// ============================================================
// SKILLZ — Radial Graph Application
// ============================================================

const APPROX_TOKENS_PER_CHAR = 0.25;

// State
let manifest = null;
let skillContents = {};
let selected = new Set();
let nodeMap = {};
let nodePositions = {};  // id -> { x, y, w, h }
let parentMap = {};
let treeData = null;
let customLayout = {};   // id -> { nx, ny } normalized 0-1 coords from layout.json
let currentSize = 700;   // track current graph size for coordinate conversion
let dragState = null;     // { id, startX, startY, origX, origY } when dragging
let zoomBehavior = null;  // d3-zoom instance
let zoomGroup = null;     // <g> element that d3-zoom transforms

// DOM refs
const graphSvg = document.getElementById('graph-svg');
const graphContainer = document.getElementById('graph-container');
const loadoutItems = document.getElementById('loadout-items');
const loadoutEmpty = document.getElementById('loadout-empty');
const tokenCountEl = document.getElementById('token-count');
const tooltipEl = document.getElementById('tooltip');
const btnCopy = document.getElementById('btn-copy');
const btnClear = document.getElementById('btn-clear');

// ---- INIT ----

async function init() {
  const res = await fetch('skills.json');
  manifest = await res.json();
  treeData = manifest.tree;

  // Load custom layout (optional — empty object means use auto-layout)
  try {
    const layoutRes = await fetch('layout.json');
    if (layoutRes.ok) customLayout = await layoutRes.json();
  } catch (e) { /* no layout file — use auto-layout */ }

  buildMaps(treeData, null);
  await preloadContent();
  renderGraph();
  initZoom();

  btnCopy.addEventListener('click', copyLoadout);
  btnClear.addEventListener('click', clearSelection);
  const btnExport = document.getElementById('btn-export');
  btnExport.addEventListener('click', exportLayout);
  btnExport.disabled = false;
  document.getElementById('btn-reset-zoom').addEventListener('click', resetZoom);

  window.addEventListener('resize', debounce(() => {
    // Don't reset positions or zoom on resize — just update SVG dimensions
    // The zoom transform keeps everything in place
  }, 200));
}

function buildMaps(node, parent) {
  nodeMap[node.id] = node;
  if (parent) parentMap[node.id] = parent.id;
  if (node.children) {
    node.children.forEach(child => buildMaps(child, node));
  }
}

async function preloadContent() {
  const paths = new Set();
  function collectPaths(node) {
    if (node.skillPath) paths.add(node.skillPath);
    if (node.templatePath) paths.add(node.templatePath);
    if (node.children) node.children.forEach(collectPaths);
  }
  collectPaths(treeData);

  await Promise.all([...paths].map(async (path) => {
    try {
      const res = await fetch(path);
      if (res.ok) skillContents[path] = await res.text();
    } catch (e) { console.warn('Failed to load:', path); }
  }));
}

// ---- RADIAL LAYOUT ----

function computeLeafCount(node) {
  if (!node.children || node.children.length === 0) return 1;
  return node.children.reduce((sum, c) => sum + computeLeafCount(c), 0);
}

// Graph uses a fixed 1000x1000 coordinate space.
// d3-zoom handles panning/scaling to fit the viewport.
const GRAPH_SIZE = 1000;

function assignRadialPositions() {
  const size = GRAPH_SIZE;
  currentSize = size;

  const cx = size / 2;
  const cy = size / 2;

  // Ring radii
  const ringRadii = [0, size * 0.2, size * 0.42];
  const nodeW = 130;
  const nodeH = 44;

  // Helper: apply custom layout position if present, otherwise use computed position
  function placeNode(id, computedX, computedY, w, h) {
    if (customLayout[id]) {
      nodePositions[id] = {
        x: customLayout[id].nx * size,
        y: customLayout[id].ny * size,
        w: w,
        h: h
      };
    } else {
      nodePositions[id] = { x: computedX, y: computedY, w: w, h: h };
    }
  }

  // Root at center
  placeNode(treeData.id, cx, cy, nodeW + 40, nodeH + 20);

  if (!treeData.children) return { size };

  const totalLeaves = computeLeafCount(treeData);

  // Assign arcs to each ring-1 child proportional to their leaf count
  let angleOffset = -Math.PI / 2; // start from top
  const fullArc = Math.PI * 2;
  const ring1Gap = 0.06; // small gap between category arcs in radians

  treeData.children.forEach((cat, i) => {
    const catLeaves = computeLeafCount(cat);
    const catArc = (catLeaves / totalLeaves) * (fullArc - ring1Gap * treeData.children.length);

    const catAngle = angleOffset + catArc / 2;
    const catX = cx + Math.cos(catAngle) * ringRadii[1];
    const catY = cy + Math.sin(catAngle) * ringRadii[1];
    placeNode(cat.id, catX, catY, nodeW, nodeH);

    // Ring 2: children of this category
    if (cat.children && cat.children.length > 0) {
      const childCount = cat.children.length;
      const childArcStart = angleOffset;
      const childArcPer = catArc / childCount;

      cat.children.forEach((child, j) => {
        const childAngle = childArcStart + childArcPer * (j + 0.5);
        const childX = cx + Math.cos(childAngle) * ringRadii[2];
        const childY = cy + Math.sin(childAngle) * ringRadii[2];
        placeNode(child.id, childX, childY, nodeW, nodeH);
      });
    }

    angleOffset += catArc + ring1Gap;
  });

  return { size, cx, cy, ringRadii };
}

// ---- GRAPH RENDERING ----

function renderGraph() {
  nodePositions = {};
  const { size, cx, cy, ringRadii } = assignRadialPositions();

  // SVG has no viewBox — it fills its container in screen pixels.
  // d3-zoom applies a transform to the inner <g> group.
  graphSvg.removeAttribute('viewBox');
  graphSvg.innerHTML = '';

  // Create the zoom-controlled content group
  zoomGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  zoomGroup.setAttribute('id', 'zoom-group');
  graphSvg.appendChild(zoomGroup);

  // Ring guide circles
  if (ringRadii) {
    const guidesGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    ringRadii.forEach((r, i) => {
      if (i === 0) return;
      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      circle.classList.add('ring-guide');
      circle.setAttribute('cx', cx);
      circle.setAttribute('cy', cy);
      circle.setAttribute('r', r);
      guidesGroup.appendChild(circle);
    });
    zoomGroup.appendChild(guidesGroup);
  }

  // Edges
  const edgesGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  edgesGroup.setAttribute('id', 'edges-group');
  drawEdges(treeData, edgesGroup);
  zoomGroup.appendChild(edgesGroup);

  // Nodes
  const nodesGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  let idx = 0;
  drawNodes(treeData, nodesGroup, () => idx++);
  zoomGroup.appendChild(nodesGroup);
}

function initZoom() {
  const svg = d3.select(graphSvg);
  const g = d3.select(zoomGroup);

  zoomBehavior = d3.zoom()
    .scaleExtent([0.1, 4])
    .on('zoom', (event) => {
      g.attr('transform', event.transform);
    });

  svg.call(zoomBehavior);

  // Disable double-click zoom (interferes with node double-click)
  svg.on('dblclick.zoom', null);

  // Fit the graph to the viewport on initial load
  fitToView();
}

function fitToView() {
  const svg = d3.select(graphSvg);
  const svgW = graphSvg.clientWidth;
  const svgH = graphSvg.clientHeight;
  if (!svgW || !svgH) return;

  // Calculate bounding box of all nodes
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  for (const id in nodePositions) {
    const p = nodePositions[id];
    minX = Math.min(minX, p.x - p.w / 2);
    minY = Math.min(minY, p.y - p.h / 2);
    maxX = Math.max(maxX, p.x + p.w / 2);
    maxY = Math.max(maxY, p.y + p.h / 2);
  }

  const contentW = maxX - minX;
  const contentH = maxY - minY;
  const padding = 40;
  const scale = Math.min(
    (svgW - padding * 2) / contentW,
    (svgH - padding * 2) / contentH,
    1.5 // don't zoom in too much
  );

  const centerX = (minX + maxX) / 2;
  const centerY = (minY + maxY) / 2;
  const tx = svgW / 2 - centerX * scale;
  const ty = svgH / 2 - centerY * scale;

  const initialTransform = d3.zoomIdentity.translate(tx, ty).scale(scale);
  svg.call(zoomBehavior.transform, initialTransform);
}

function resetZoom() {
  fitToView();
}

function drawEdges(node, group) {
  if (!node.children) return;
  const p = nodePositions[node.id];
  // Get graph center for arc direction
  const rootPos = nodePositions[treeData.id];
  const gcx = rootPos ? rootPos.x : p.x;
  const gcy = rootPos ? rootPos.y : p.y;

  node.children.forEach(child => {
    const c = nodePositions[child.id];

    // Edge exits from the border of parent toward child,
    // and enters at the border of child from parent direction.
    const pEdge = rectEdgePoint(p, c.x, c.y);
    const cEdge = rectEdgePoint(c, p.x, p.y);

    // Control point: push the midpoint outward from graph center
    // to create a gentle arc that avoids cutting through nodes.
    const midX = (pEdge.x + cEdge.x) / 2;
    const midY = (pEdge.y + cEdge.y) / 2;

    // Vector from center to midpoint
    const vmx = midX - gcx;
    const vmy = midY - gcy;
    const vmLen = Math.sqrt(vmx * vmx + vmy * vmy) || 1;

    // Push control point outward by a fraction of the edge length
    const edgeDx = cEdge.x - pEdge.x;
    const edgeDy = cEdge.y - pEdge.y;
    const edgeLen = Math.sqrt(edgeDx * edgeDx + edgeDy * edgeDy);
    const bulge = edgeLen * 0.2;

    const cpx = midX + (vmx / vmLen) * bulge;
    const cpy = midY + (vmy / vmLen) * bulge;

    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', `M ${pEdge.x} ${pEdge.y} Q ${cpx} ${cpy} ${cEdge.x} ${cEdge.y}`);
    path.classList.add('graph-edge');
    path.setAttribute('data-from', node.id);
    path.setAttribute('data-to', child.id);
    group.appendChild(path);

    drawEdges(child, group);
  });
}

// Get the point on a node's rounded-rect border closest to a target point.
function rectEdgePoint(pos, tx, ty) {
  const hw = pos.w / 2;
  const hh = pos.h / 2;
  const dx = tx - pos.x;
  const dy = ty - pos.y;
  const angle = Math.atan2(dy, dx);

  // Find intersection with rect edges
  let ix, iy;
  const tanA = Math.abs(Math.tan(angle));
  if (tanA <= hh / hw) {
    // Intersects left or right edge
    ix = dx > 0 ? hw : -hw;
    iy = ix * Math.tan(angle);
  } else {
    // Intersects top or bottom edge
    iy = dy > 0 ? hh : -hh;
    ix = iy / Math.tan(angle);
  }

  return { x: pos.x + ix, y: pos.y + iy };
}

function drawNodes(node, group, getIndex) {
  const pos = nodePositions[node.id];
  if (!pos) return;

  const idx = getIndex();
  const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  g.classList.add('graph-node');
  g.setAttribute('data-id', node.id);
  g.style.animationDelay = (idx * 40) + 'ms';
  g.style.transformOrigin = `${pos.x}px ${pos.y}px`;

  if (node.type === 'root') g.classList.add('root-node');

  // Node rectangle
  const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
  rect.classList.add('node-body');
  rect.setAttribute('x', pos.x - pos.w / 2);
  rect.setAttribute('y', pos.y - pos.h / 2);
  rect.setAttribute('width', pos.w);
  rect.setAttribute('height', pos.h);
  rect.setAttribute('rx', 6);
  rect.setAttribute('ry', 6);
  g.appendChild(rect);

  // Type badge
  if (node.type !== 'root') {
    const badge = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    badge.classList.add('node-type-badge', 'badge-' + node.type);
    badge.setAttribute('x', pos.x);
    badge.setAttribute('y', pos.y - 7);
    badge.textContent = node.type;
    g.appendChild(badge);
  }

  // Label
  const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
  label.classList.add('node-label');
  label.setAttribute('x', pos.x);
  label.setAttribute('y', pos.y + (node.type === 'root' ? 0 : 7));
  label.textContent = truncateLabel(node.label, node.type === 'root' ? 20 : 15);
  g.appendChild(label);

  // Drag + click: mousedown starts potential drag, mouseup without move = click
  g.addEventListener('mousedown', (e) => {
    if (e.button !== 0) return;
    e.preventDefault();
    e.stopPropagation();
    startDrag(e, node);
  });

  g.addEventListener('touchstart', (e) => {
    e.preventDefault();
    e.stopPropagation();
    const touch = e.touches[0];
    startDrag(touch, node);
  }, { passive: false });

  // Tooltip
  g.addEventListener('mouseenter', (e) => { if (!dragState) showTooltip(e, node); });
  g.addEventListener('mouseleave', hideTooltip);
  g.addEventListener('mousemove', (e) => { if (!dragState) moveTooltip(e); });

  group.appendChild(g);

  if (node.children) {
    node.children.forEach(child => drawNodes(child, group, getIndex));
  }
}

function truncateLabel(label, max) {
  return label.length > max ? label.slice(0, max - 2) + '..' : label;
}

// ---- SELECTION LOGIC ----

// Clicking any node that has children selects EVERYTHING underneath.
// Clicking a leaf selects just that leaf (+ parent skill core if template).
// Clicking again deselects.

function handleNodeClick(node) {
  const descendants = getAllDescendants(node);
  const self = [node.id];
  const allIds = [...self, ...descendants.map(d => d.id)];

  // Check if fully selected already
  const allSelected = allIds.every(id => selected.has(id));

  if (allSelected) {
    // Deselect everything
    allIds.forEach(id => selected.delete(id));

    // If we deselected templates, also check if parent skill core should be deselected
    descendants.forEach(d => {
      if (d.type === 'template' && d.parentSkill) {
        const parent = nodeMap[d.parentSkill];
        if (parent && parent.children) {
          const anyLeft = parent.children.some(c => c.type === 'template' && selected.has(c.id));
          if (!anyLeft) selected.delete(d.parentSkill);
        }
      }
    });
  } else {
    // Select everything
    allIds.forEach(id => {
      const n = nodeMap[id];
      selected.add(id);
      // Auto-select parent skill core for templates
      if (n.type === 'template' && n.parentSkill) {
        selected.add(n.parentSkill);
      }
    });

    // If this node IS a category with a skillPath (hybrid), select it too
    if (node.skillPath) selected.add(node.id);
  }

  updateUI();
}

function getAllDescendants(node) {
  if (!node.children) return [];
  let result = [];
  node.children.forEach(child => {
    result.push(child);
    result = result.concat(getAllDescendants(child));
  });
  return result;
}

function getAncestors(id) {
  const ancestors = [];
  let current = parentMap[id];
  while (current) {
    ancestors.push(current);
    current = parentMap[current];
  }
  return ancestors;
}

function clearSelection() {
  selected.clear();
  updateUI();
}

// ---- UI UPDATE ----

function updateUI() {
  updateNodeStyles();
  updateEdgeStyles();
  updateLoadoutTray();
  updateButtons();
}

function updateNodeStyles() {
  const ancestors = new Set();
  selected.forEach(id => {
    getAncestors(id).forEach(a => ancestors.add(a));
  });

  document.querySelectorAll('.graph-node').forEach(g => {
    const id = g.getAttribute('data-id');
    g.classList.toggle('selected', selected.has(id));
    g.classList.toggle('ancestor', !selected.has(id) && ancestors.has(id));
  });
}

function updateEdgeStyles() {
  const highlighted = new Set();

  selected.forEach(id => {
    let current = id;
    while (parentMap[current]) {
      highlighted.add(parentMap[current] + '->' + current);
      current = parentMap[current];
    }
  });

  document.querySelectorAll('.graph-edge').forEach(edge => {
    const from = edge.getAttribute('data-from');
    const to = edge.getAttribute('data-to');
    edge.classList.toggle('highlighted', highlighted.has(from + '->' + to));
  });
}

function updateLoadoutTray() {
  const items = getLoadoutItems();

  if (items.length === 0) {
    loadoutItems.innerHTML = '';
    loadoutEmpty.style.display = 'block';
    tokenCountEl.textContent = '';
    return;
  }

  loadoutEmpty.style.display = 'none';
  let totalTokens = 0;
  loadoutItems.innerHTML = '';

  items.forEach(item => {
    const tokens = estimateTokens(item.content);
    totalTokens += tokens;

    const chip = document.createElement('div');
    chip.className = 'loadout-chip chip-' + item.type;
    chip.innerHTML = `
      ${item.path ? `<span class="chip-path">${item.path} /</span>` : ''}
      <span class="chip-name">${item.name}</span>
      <span class="chip-tokens">${formatTokens(tokens)}</span>
      <span class="chip-remove" data-id="${item.id}">&times;</span>
    `;

    chip.querySelector('.chip-remove').addEventListener('click', (e) => {
      e.stopPropagation();
      const removeId = e.target.dataset.id;
      const removeNode = nodeMap[removeId];
      // Deselect just this item
      selected.delete(removeId);
      // If template, check if parent core should be deselected
      if (removeNode.type === 'template' && removeNode.parentSkill) {
        const parent = nodeMap[removeNode.parentSkill];
        if (parent && parent.children) {
          const anyLeft = parent.children.some(c => c.type === 'template' && selected.has(c.id));
          if (!anyLeft) selected.delete(removeNode.parentSkill);
        }
      }
      updateUI();
    });

    loadoutItems.appendChild(chip);
  });

  tokenCountEl.innerHTML = `<span class="num">${formatTokens(totalTokens)}</span> tokens`;
}

function getLoadoutItems() {
  const items = [];

  selected.forEach(id => {
    const node = nodeMap[id];

    if (node.type === 'skill') {
      items.push({
        id: node.id,
        name: node.label,
        path: getCategoryPath(id),
        type: 'skill',
        content: skillContents[node.skillPath] || ''
      });
    } else if (node.type === 'template') {
      items.push({
        id: node.id,
        name: node.label,
        path: getCategoryPath(id),
        type: 'template',
        content: skillContents[node.templatePath] || ''
      });
    } else if (node.type === 'category' && node.skillPath) {
      items.push({
        id: node.id,
        name: node.label + ' (core)',
        path: '',
        type: 'skill',
        content: getSkillCoreContent(node.skillPath)
      });
    }
  });

  return items;
}

function getCategoryPath(id) {
  const parts = [];
  let current = parentMap[id];
  while (current && nodeMap[current].type !== 'root') {
    parts.unshift(nodeMap[current].label);
    current = parentMap[current];
  }
  return parts.join(' / ');
}

function getSkillCoreContent(path) {
  const content = skillContents[path] || '';
  const marker = '<!-- skillz:select -->';
  const idx = content.indexOf(marker);
  if (idx !== -1) return content.substring(0, idx).trimEnd();
  return content;
}

function updateButtons() {
  const hasSelection = selected.size > 0;
  btnCopy.disabled = !hasSelection;
  btnClear.disabled = !hasSelection;
}

// ---- STITCHING & COPY ----

async function copyLoadout() {
  const output = stitchLoadout();

  try {
    await navigator.clipboard.writeText(output);
    btnCopy.textContent = 'copied!';
    btnCopy.classList.add('copied');
    setTimeout(() => {
      btnCopy.textContent = 'copy loadout';
      btnCopy.classList.remove('copied');
    }, 2000);
  } catch (e) {
    console.error('Copy failed:', e);
  }
}

function stitchLoadout() {
  const parts = [];

  // Standalone skills
  selected.forEach(id => {
    const node = nodeMap[id];
    if (node.type === 'skill' && node.skillPath) {
      parts.push(skillContents[node.skillPath] || '');
    }
  });

  // Category-skills with their selected templates
  selected.forEach(id => {
    const node = nodeMap[id];
    if (node.type === 'category' && node.skillPath && node.hasSelectMarker) {
      const core = getSkillCoreContent(node.skillPath);
      parts.push(core);

      if (node.children) {
        node.children.forEach(child => {
          if (child.type === 'template' && selected.has(child.id)) {
            parts.push(skillContents[child.templatePath] || '');
          }
        });
      }
    }
  });

  return parts.join('\n\n');
}

// ---- TOKEN ESTIMATION ----

function estimateTokens(text) {
  if (!text) return 0;
  return Math.round(text.length * APPROX_TOKENS_PER_CHAR);
}

function formatTokens(n) {
  if (n >= 1000) return (n / 1000).toFixed(1) + 'k';
  return n.toString();
}

// ---- TOOLTIP ----

function showTooltip(e, node) {
  let content = `<div class="tip-name">${node.label}</div>`;

  if (node.type === 'skill' || (node.type === 'category' && node.skillPath)) {
    const raw = skillContents[node.skillPath] || '';
    const desc = extractDescription(raw);
    if (desc) content += `<div class="tip-desc">${desc}</div>`;
  } else if (node.type === 'template') {
    const raw = skillContents[node.templatePath] || '';
    const firstLine = raw.split('\n').find(l => l.trim() && !l.startsWith('#') && !l.startsWith('---'));
    if (firstLine) content += `<div class="tip-desc">${firstLine.trim()}</div>`;
  } else if (node.type === 'category') {
    const childCount = node.children ? node.children.length : 0;
    content += `<div class="tip-desc">click to select all ${childCount} skills</div>`;
  }

  tooltipEl.innerHTML = content;
  tooltipEl.classList.add('visible');
  moveTooltip(e);
}

function moveTooltip(e) {
  const pad = 12;
  let x = e.clientX + pad;
  let y = e.clientY + pad;

  const rect = tooltipEl.getBoundingClientRect();
  if (x + rect.width > window.innerWidth - pad) x = e.clientX - rect.width - pad;
  if (y + rect.height > window.innerHeight - pad) y = e.clientY - rect.height - pad;

  tooltipEl.style.left = x + 'px';
  tooltipEl.style.top = y + 'px';
}

function hideTooltip() {
  tooltipEl.classList.remove('visible');
}

function extractDescription(markdown) {
  const match = markdown.match(/^---\s*\n([\s\S]*?)\n---/);
  if (match) {
    const fm = match[1];
    const descMatch = fm.match(/description:\s*([^\n]+(?:\n\s+[^\n]+)*)/);
    if (descMatch) return descMatch[1].trim().replace(/\n\s*/g, ' ').slice(0, 250);
  }
  return null;
}

// ---- DRAG TO REPOSITION ----

const DRAG_THRESHOLD = 5; // pixels before mousedown becomes a drag

function startDrag(e, node) {
  dragState = {
    id: node.id,
    node: node,
    startClientX: e.clientX,
    startClientY: e.clientY,
    origX: nodePositions[node.id].x,
    origY: nodePositions[node.id].y,
    hasMoved: false
  };

  // Attach move/up to window so drag works outside the node
  window.addEventListener('mousemove', onDragMove);
  window.addEventListener('mouseup', onDragEnd);
  window.addEventListener('touchmove', onTouchDragMove, { passive: false });
  window.addEventListener('touchend', onTouchDragEnd);
}

function onTouchDragMove(e) {
  e.preventDefault();
  const touch = e.touches[0];
  onDragMove(touch);
}

function onTouchDragEnd(e) {
  const touch = e.changedTouches[0];
  onDragEnd(touch);
}

function onDragMove(e) {
  if (!dragState) return;

  const dx = e.clientX - dragState.startClientX;
  const dy = e.clientY - dragState.startClientY;

  // Check if we've exceeded the drag threshold
  if (!dragState.hasMoved && Math.sqrt(dx * dx + dy * dy) < DRAG_THRESHOLD) return;
  dragState.hasMoved = true;

  // Hide tooltip during drag
  hideTooltip();

  // Convert client delta to graph coordinate delta using the zoom group's CTM.
  // The zoom group's getScreenCTM() includes the d3-zoom transform,
  // so dividing by its scale gives us the correct graph-space delta.
  const ctm = zoomGroup.getScreenCTM();
  const svgDx = dx / ctm.a;
  const svgDy = dy / ctm.d;

  const newX = dragState.origX + svgDx;
  const newY = dragState.origY + svgDy;

  // Update position
  const pos = nodePositions[dragState.id];
  pos.x = newX;
  pos.y = newY;

  // Update the node's SVG elements
  updateNodePosition(dragState.id);

  // Redraw all edges connected to this node
  redrawEdges();
}

function onDragEnd(e) {
  if (!dragState) return;

  window.removeEventListener('mousemove', onDragMove);
  window.removeEventListener('mouseup', onDragEnd);
  window.removeEventListener('touchmove', onTouchDragMove);
  window.removeEventListener('touchend', onTouchDragEnd);

  if (!dragState.hasMoved) {
    // This was a click, not a drag
    handleNodeClick(dragState.node);
  } else {
    // Drag completed — update the custom layout with normalized coordinates
    const pos = nodePositions[dragState.id];
    customLayout[dragState.id] = {
      nx: pos.x / currentSize,
      ny: pos.y / currentSize
    };
    // Enable the export button since layout has been modified
    const btnExport = document.getElementById('btn-export');
    if (btnExport) btnExport.disabled = false;
  }

  dragState = null;
}

function updateNodePosition(id) {
  const pos = nodePositions[id];
  const container = zoomGroup || graphSvg;
  const g = container.querySelector(`.graph-node[data-id="${id}"]`);
  if (!g) return;

  // Update transform origin for animation
  g.style.transformOrigin = `${pos.x}px ${pos.y}px`;

  // Update rect
  const rect = g.querySelector('.node-body');
  if (rect) {
    rect.setAttribute('x', pos.x - pos.w / 2);
    rect.setAttribute('y', pos.y - pos.h / 2);
  }

  // Update badge
  const badge = g.querySelector('.node-type-badge');
  if (badge) {
    badge.setAttribute('x', pos.x);
    badge.setAttribute('y', pos.y - 7);
  }

  // Update label
  const label = g.querySelector('.node-label');
  if (label) {
    const node = nodeMap[id];
    label.setAttribute('x', pos.x);
    label.setAttribute('y', pos.y + (node && node.type === 'root' ? 0 : 7));
  }
}

function redrawEdges() {
  // Remove all existing edges and redraw
  const edgesGroup = zoomGroup ? zoomGroup.querySelector('#edges-group') : document.getElementById('edges-group');
  if (!edgesGroup) return;
  edgesGroup.innerHTML = '';
  drawEdges(treeData, edgesGroup);
  // Re-apply highlight styles
  updateEdgeStyles();
}

// ---- EXPORT LAYOUT ----

async function exportLayout() {
  // Build a clean layout object from current positions
  const layout = {};
  for (const id in nodePositions) {
    layout[id] = {
      nx: Math.round((nodePositions[id].x / currentSize) * 10000) / 10000,
      ny: Math.round((nodePositions[id].y / currentSize) * 10000) / 10000
    };
  }

  const json = JSON.stringify(layout, null, 2);

  try {
    await navigator.clipboard.writeText(json);
    const btnExport = document.getElementById('btn-export');
    if (btnExport) {
      btnExport.textContent = 'copied!';
      btnExport.classList.add('copied');
      setTimeout(() => {
        btnExport.textContent = 'export layout';
        btnExport.classList.remove('copied');
      }, 2000);
    }
  } catch (e) {
    console.error('Export copy failed:', e);
  }
}

// ---- UTILS ----

function debounce(fn, ms) {
  let timer;
  return (...args) => { clearTimeout(timer); timer = setTimeout(() => fn(...args), ms); };
}

// ---- GO ----

init();
</script>

</body>
</html>
